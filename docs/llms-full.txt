# BEAR.Resource - Complete Documentation

BEAR.Resource is a PHP hypermedia framework that implements REST resource-oriented architecture (ROA) with "object as a service" patterns. It enables objects to behave as REST resources with client-server architecture, uniform interfaces, statelessness, and hypermedia connectivity.

## Core Architecture

### Resource Object Pattern
Every resource extends `ResourceObject` and implements HTTP methods as PHP methods:

```php
class Author extends ResourceObject
{
    public $code = 200;
    public $headers = ['Content-Type' => 'application/json'];
    public $body = ['id' => 1, 'name' => 'koriym'];

    public function onGet(int $id): static
    {
        // Handle GET request
        return $this;
    }

    public function onPost(string $name): static
    {
        $this->code = 201; // Created
        return $this;
    }

    public function onPut(int $id, string $name): static
    {
        $this->code = 204; // No Content
        return $this;
    }

    public function onDelete(int $id): static
    {
        $this->code = 204; // No Content
        return $this;
    }
}
```

### URI Scheme Mapping
Resources are accessed via URI schemes that map to PSR-4 classes:
- `app://self/user/123` → `App\Resource\User` class
- `http://api.example.com/user/123` → External HTTP resource
- `page://self/user` → Page resource

### Resource Properties
All resources have four core properties:
- `$code`: HTTP status code (200, 201, 404, etc.)
- `$headers`: Array of HTTP headers
- `$body`: Resource data/payload
- `$view`: Rendered representation

## Dependency Injection System

Uses Ray.Di for comprehensive dependency injection:

```php
use BEAR\Resource\ResourceInterface;

$resource = (new Injector(new ResourceModule('MyApp')))->getInstance(ResourceInterface::class);
```

### Method Parameter Injection
Resource methods support automatic parameter injection:

```php
public function onGet(int $id, UserRepository $repo, LoggerInterface $logger): ResourceObject
{
    $user = $repo->findById($id);
    $logger->info("User {$id} retrieved", ['user' => $user]);
    $this->body = $user;
    return $this;
}
```

## Request Patterns

### Eager Request (Immediate Execution)
```php
$user = $resource->get('app://self/user', ['id' => 1]);
// Alternative syntaxes:
$user = $resource->get->uri('app://self/user')->withQuery(['id' => 1])->eager->request();
$user = $resource->get->uri('app://self/user')(['id' => 1]);
$user = $resource->uri('app://self/user')(['id' => 1]); // GET is default
```

### Lazy Request (Deferred Execution)
```php
$userRequest = $resource->get->uri('app://self/user')->withQuery(['id' => 1]);
// Executed when accessed:
echo "User: {$userRequest}"; // Triggers execution and rendering
// Or invoke with different parameters:
$user1 = $userRequest();
$user2 = $userRequest(['id' => 2]);
```

## Hypermedia & HATEOAS

### Link Annotations
Resources define hyperlinks using `#[Link]` attributes:

```php
#[Link(rel: 'blog', href: 'app://self/blog?author_id={id}')]
#[Link(rel: 'profile', href: 'app://self/user/profile?user_id={id}')]
public function onGet(int $id): static
{
    // Link templates use current resource values
    $this->body = ['id' => $id, 'name' => 'John'];
    return $this;
}
```

### Link Navigation

**linkSelf**: Replace current resource with linked resource
```php
$blog = $resource->get->uri('app://self/user')->withQuery(['id' => 1])
    ->linkSelf('blog')->eager->request();
```

**linkNew**: Add linked resource to current response
```php
$user = $resource->get->uri('app://self/user')->withQuery(['id' => 1])
    ->linkNew('blog')->eager->request();
$blog = $user['blog']; // Linked resource available
```

**linkCrawl**: Build complex resource graphs
```php
// Author → Posts → Meta + Tags → Tag Names
#[Link(crawl: 'post-tree', rel: 'post', href: 'app://self/post?author_id={id}')]
public function onGet($id) {} // Author

#[Link(crawl: 'post-tree', rel: 'meta', href: 'app://self/meta?post_id={id}')]
#[Link(crawl: 'post-tree', rel: 'tag', href: 'app://self/tag?post_id={id}')]
public function onGet($author_id) {} // Post

$graph = $resource->get->uri('app://self/author')->linkCrawl('post-tree')->eager->request();
```

### HATEOAS Workflow
```php
// Order resource with payment link
#[Link(rel: 'payment', href: 'app://self/payment{?order_id,amount}', method: 'put')]
public function onPost($drink) {} // Order

// Client follows hyperlink for state transition
$order = $resource->post('app://self/order', ['drink' => 'latte']);
$payment = $resource->href('payment', ['amount' => '4.00']); // Follow hyperlink
```

## Parameter Binding

### Web Context Parameters
Bind HTTP context values to method parameters:

```php
use Ray\WebContextParam\Annotation\QueryParam;
use Ray\WebContextParam\Annotation\CookieParam;
use Ray\WebContextParam\Annotation\FormParam;
use Ray\WebContextParam\Annotation\ServerParam;

public function onGet(
    #[QueryParam('user_id')] string $userId,    // $_GET['user_id']
    #[CookieParam('token')] string $token,      // $_COOKIE['token']
    #[FormParam('data')] string $data,          // $_POST['data']
    #[ServerParam('HTTP_HOST')] string $host    // $_SERVER['HTTP_HOST']
): ResourceObject {}
```

### Resource Parameters
Bind another resource's state to parameters:

```php
use BEAR\Resource\Annotation\ResourceParam;

/**
 * @ResourceParam(param="userName", uri="app://self/login#nickname")
 */
public function onGet(string $userName): ResourceObject
{
    // $userName contains the 'nickname' property from app://self/login resource
}
```

## Input Handling (Ray.InputQuery Integration)

### Input Objects
Convert flat query data to structured, type-safe objects:

```php
use Ray\InputQuery\Attribute\Input;

class ArticleInput
{
    public function __construct(
        public readonly string $title,
        public readonly string $content,
        public readonly AuthorInput $author
    ) {}
}

class ArticleResource extends ResourceObject
{
    public function onPost(#[Input] ArticleInput $article): static
    {
        $this->body = [
            'title' => $article->title,
            'author_name' => $article->author->name
        ];
        return $this;
    }
}
```

### File Upload Processing
Type-safe file upload with validation:

```php
use Ray\InputQuery\Attribute\InputFile;
use Koriym\FileUpload\FileUpload;
use Koriym\FileUpload\ErrorFileUpload;

public function onPost(
    #[InputFile(
        maxSize: 1024 * 1024, // 1MB
        allowedTypes: ['image/jpeg', 'image/png'],
        allowedExtensions: ['jpg', 'png']
    )]
    FileUpload|ErrorFileUpload $image,
    string $title = 'Default'
): static {
    if ($image instanceof ErrorFileUpload) {
        $this->code = 400;
        $this->body = ['error' => $image->message];
        return $this;
    }

    $filename = uniqid() . '_' . $image->name;
    $image->move('/uploads/' . $filename);
    
    $this->body = [
        'filename' => $image->name,
        'size' => $image->size,
        'type' => $image->type
    ];
    return $this;
}
```

## Resource Embedding

Embed external resources using `#[Embed]`:

```php
class News extends ResourceObject
{
    #[Embed(rel: 'weather', src: 'app://self/weather/today')]
    #[Embed(rel: 'stocks', src: 'app://self/stocks/quotes')]
    public function onGet(): static
    {
        $this->body = [
            'headline' => 'Breaking News',
            'content' => 'Article content...'
        ];
        return $this;
    }
}
```

## Representation & Rendering

### JSON Rendering
```php
$modules = [new ResourceModule('MyApp'), new JsonModule()];
$resource = (new Injector($modules))->getInstance(ResourceInterface::class);
$user = $resource->get('app://self/user', ['id' => 1]);
echo $user; // JSON output
```

### HAL (Hypertext Application Language) Rendering
```php
$modules = [new ResourceModule('MyApp'), new HalModule()];
$resource = (new Injector($modules))->getInstance(ResourceInterface::class);
echo $resource->get('app://self/news'); 
// HAL format with _links and _embedded sections
```

### Custom Renderers
```php
class User extends ResourceObject
{
    public function __construct()
    {
        $this->setRenderer(new class implements RenderInterface {
            public function render(ResourceObject $ro): string
            {
                $ro->headers['content-type'] = 'application/xml';
                $ro->view = $this->toXml($ro->body);
                return $ro->view;
            }
        });
    }
}
```

## Transfer & Output

Transfer resource state to client:

```php
$user = $resource->get('app://self/user', ['id' => 1]);
$user->transfer(new class implements TransferInterface {
    public function __invoke(ResourceObject $ro, array $server): void
    {
        foreach ($ro->headers as $label => $value) {
            header("{$label}: {$value}", false);
        }
        http_response_code($ro->code);
        echo $ro->view;
    }
});
```

## Module System

### Core Modules
- `ResourceModule`: Basic resource functionality
- `JsonModule`: JSON representation
- `HalModule`: HAL representation  
- `HttpClientModule`: HTTP resource client
- `EmbedResourceModule`: Resource embedding

### Module Configuration
```php
class AppModule extends AbstractModule
{
    protected function configure(): void
    {
        $this->install(new ResourceModule('MyApp'));
        $this->install(new JsonModule());
        $this->install(new HalModule());
    }
}
```

## Why Hierarchical Semantic Logging Exists

### What is Hierarchical vs Flat Logging?

**Flat Logging (Traditional)**:
```
[INFO] Started order processing
[INFO] Validating payment method  
[INFO] Calling Stripe API
[INFO] Payment completed
[INFO] Order processing finished
```

**Hierarchical Semantic Logging**:
```json
{
  "open": {"id": "order_1", "type": "order_processing"},
  "open": {"id": "payment_1", "type": "payment_validation", "openId": "order_1"},  
  "open": {"id": "stripe_1", "type": "external_api", "openId": "payment_1"}
}
```

### The Critical Difference
**Flat**: Events appear independent → AI cannot determine relationships
**Hierarchical**: Events explicitly show parent-child relationships → AI understands causality

### Why This Structure Matches Reality
Real systems work hierarchically:
1. **Function call stack**: main() calls processOrder() calls validatePayment()  
2. **Time attribution**: Payment validation time is part of order processing time
3. **Error propagation**: Stripe failure causes payment failure causes order failure

### The AI Analysis Impact
With hierarchy, AI can answer:
- "Why did order processing take 680ms?" → Because payment took 520ms
- "What should I optimize first?" → The 247ms Stripe call within payment processing
- "If I fix Stripe, what improves?" → Payment processing AND order processing

**Without hierarchy**: AI sees disconnected events, cannot trace causality, cannot prioritize optimizations effectively.

### The Fundamental Problem Hierarchical Logging Solves
Traditional flat logging forces hierarchical reality into linear sequences, losing:
- **Causal relationships**: What operation caused what result?
- **Contextual scope**: Which operations contain which operations?  
- **Problem attribution**: Does the 200ms belong to the parent or child process?
- **Performance correlation**: How do nested operation times contribute to total time?

**Therefore**: Hierarchical semantic logging doesn't impose artificial structure - it reveals and preserves the natural hierarchical structure that already exists in how systems actually work and how problems actually occur.

## Semantic Logger Design Principles

### Core Design Philosophy

The Semantic Logger framework is built on these fundamental principles:

**Application Autonomy**: Applications define their own context types and corresponding schemas. The framework provides structure, but applications control semantics. No predefined context types are imposed.

**Framework Agnostic**: This logging system works with any application framework. It provides structural patterns (open/close/events) while letting applications define their own business contexts.

**Extensibility**: New context types can be added without framework changes. The schema system scales to any domain or application type through application-defined schemas.

**Hierarchical Correlation**: Operations are linked through `openId` references to preserve natural request flow structure. This reflects how systems actually work - through nested, related operations.

**Semantic Enrichment**: Web Links provide contextual relationships beyond pure data structure, following RFC 8288 Web Linking principles to enable AI understanding of relationships that data alone cannot express.

**Reality Reflection**: The schema structure mirrors how systems actually work - hierarchically and contextually. It doesn't impose artificial constraints but captures the natural organization of software operations.

### Why These Principles Matter

These principles ensure that:
- **AI analysis** can understand any application domain without framework-specific knowledge
- **Performance debugging** follows natural system boundaries rather than arbitrary log categories  
- **Error tracking** preserves causal relationships that exist in real system execution
- **Scalability** works across different programming languages, frameworks, and application types

The framework succeeds when it becomes invisible - when the logged structure naturally matches how developers think about their systems.

## Semantic Logging Integration

BEAR.Resource includes comprehensive semantic logging for observability:

### Semantic Logger Components
- `SemanticLogger`: Main logging interface with structured JSON output
- `SemanticInvoker`: Wraps resource invocation with automatic logging
- `OpenContext`: Request initiation context
- `CompleteContext`: Request completion with profiling data
- `ErrorContext`: Exception and error contexts

### Profile Integration
- **XHProf**: Lightweight performance profiling
- **Xdebug**: Detailed function call tracing
- Automatic profile file generation and linking

### OpenId: Hierarchical Operation Correlation System

**Critical Concept**: The `openId` field is SemanticLogger's core mechanism for linking operations across the open/event/close lifecycle and establishing hierarchical relationships between nested operations.

#### OpenId Correlation Pattern
Every `close` and `event` entry contains an `openId` field that references the `id` of its corresponding `open` entry:

```json
{
    "open": {
        "id": "http_request_1",              // ← This ID
        "type": "http_request",
        "context": {...}
    },
    "close": {
        "id": "http_response_1",
        "type": "http_response", 
        "openId": "http_request_1",          // ← Links to above open ID
        "context": {...}
    },
    "events": [
        {
            "id": "cache_operation_1",
            "type": "cache_operation",
            "openId": "http_request_1",      // ← Also links to same open ID
            "context": {...}
        }
    ]
}
```

#### Hierarchical Nesting with OpenId
In nested operations, `openId` creates parent-child relationships enabling complete request flow analysis:

```json
{
    "open": {
        "id": "http_request_1",              // Top-level operation
        "type": "http_request",
        "open": {                            // Nested operation
            "id": "database_query_1",        // Child operation
            "type": "database_query",
            "open": {                        // Deeply nested
                "id": "cache_check_1",
                "type": "cache_operation"
            }
        }
    },
    "close": {
        "id": "cache_result_1",
        "openId": "cache_check_1",           // Links to deepest nested operation
        "close": {
            "id": "query_result_1", 
            "openId": "database_query_1",    // Links to middle operation
            "close": {
                "id": "http_response_1",
                "openId": "http_request_1"   // Links to top-level operation
            }
        }
    }
}
```

#### OpenId Business Logic Rules

1. **Correlation Identity**: Every `openId` MUST reference an existing `id` from an `open` entry
2. **Hierarchical Integrity**: Child operations close before their parent operations
3. **Scope Binding**: Events and closes are scoped to their `openId` operation
4. **Performance Attribution**: Nested operations contribute to their parent's total execution time

#### AI Analysis Guidelines for OpenId

**DO:**
- Trace complete request flows by following `openId` chains
- Calculate hierarchical performance metrics (child time contributes to parent)
- Identify operation scope and context through `openId` relationships
- Use `openId` to group related events and understand business logic flow

**DON'T:**
- Treat operations with different `openId` values as unrelated
- Ignore the hierarchical structure when calculating performance impact
- Assume events belong to the top-level operation without checking `openId`

#### OpenId Performance Analysis Example

```
http_request_1 (Total: 676ms)
├── authentication_request_1 (15ms) ← openId: http_request_1  
├── business_logic_1 (520ms) ← openId: http_request_1
│   ├── database_query_1 (45ms) ← openId: business_logic_1
│   ├── external_api_1 (247ms) ← openId: business_logic_1  
│   └── file_processing_1 (118ms) ← openId: business_logic_1
└── cache_operation_1 (3ms) ← openId: http_request_1
```

This hierarchical structure enables precise bottleneck identification: external_api_1 consumed 247ms of the business_logic_1's 520ms, which itself consumed 520ms of http_request_1's total 676ms.

### Structured Log Output
```json
{
    "schemaUrl": "https://koriym.github.io/Koriym.SemanticLogger/schemas/semantic-log.json",
    "open": {
        "id": "bear_resource_request_1",
        "type": "bear_resource_request",
        "context": {
            "method": "GET",
            "uri": "app://self/user?id=123"
        }
    },
    "close": {
        "id": "bear_resource_complete_1", 
        "type": "bear_resource_complete",
        "openId": "bear_resource_request_1",  // ← Explicit correlation
        "context": {
            "code": 200,
            "body": {"id": 123, "name": "John"},
            "xhprofFile": "/tmp/profile_123.xhprof",
            "xdebugTraceFile": "/tmp/trace_123.xt"
        }
    }
}
```

## Namespace Code Classification

### Framework vs Application Code

When analyzing profiling data or semantic logs, distinguish code types by namespace patterns:

**Framework/Library Code (NOT application code):**
- `BEAR\*` - BEAR.Resource framework components
- `Koriym\*` - Koriym library components  
- `Ray\*` - Ray.Di dependency injection framework
- `Doctrine\*` - Doctrine components
- `Composer\*` - Composer autoloader
- `vendor\*` path - Third-party vendor libraries

**Application Code:**
- `App\*` - Primary application namespace
- `FakeVendor\*` - Test/demo application namespace
- Any custom namespace outside vendor directory

**Examples:**
```
Framework: BEAR\Resource\Invoker::invoke
Framework: Ray\Di\Container::getInstance  
Framework: Koriym\SemanticLogger\SemanticLogger::open
Application: App\Resource\User::onGet
Application: FakeVendor\Sandbox\Resource\App\Bird\Canary::onGet
```

When providing performance analysis, focus on application code performance issues. Framework overhead is expected and should be excluded from optimization recommendations unless specifically requested.

## Performance Optimization

### Resource Client Serialization
Cache compiled resource clients for significant performance gains:

```php
// Build and cache
$resource = (new Injector(new ResourceModule('MyApp')))->getInstance(ResourceInterface::class);
file_put_contents('resource.cache', serialize($resource));

// Load from cache
$resource = unserialize(file_get_contents('resource.cache'));
$user = $resource->get('app://self/user', ['id' => 1]);
```

### Lazy Loading Benefits
- Assign request objects to templates instead of executed results
- Execution deferred until actually needed
- Better memory usage and performance

## Testing Patterns

### Integration Testing Approach
BEAR.Resource emphasizes integration testing over unit testing:

```php
class UserResourceTest extends TestCase
{
    private ResourceInterface $resource;

    protected function setUp(): void
    {
        $this->resource = (new Injector(new TestModule()))->getInstance(ResourceInterface::class);
    }

    public function testGetUser(): void
    {
        $user = $this->resource->get('app://self/user', ['id' => 1]);
        
        $this->assertSame(200, $user->code);
        $this->assertSame('John', $user->body['name']);
    }

    public function testFileUpload(): void
    {
        $upload = FileUpload::fromFile(__DIR__ . '/fixtures/test.jpg');
        $result = $this->resource->post('app://self/upload', ['image' => $upload]);
        
        $this->assertSame(200, $result->code);
        $this->assertTrue($result->body['success']);
    }
}
```

### Key Testing Principles
- Use real ResourceInterface instances, never mocks
- Use actual Request/Uri objects for contexts
- Use real Exception instances for error scenarios
- Leverage existing fake resources in tests/Fake/ directory
- Test integration behavior, not isolated units

## Error Handling

### Exception Types
- `ResourceNotFoundException`: Resource class not found
- `MethodException`: HTTP method not supported
- `BadRequestException`: Invalid request parameters
- `ParameterException`: Parameter binding failures

### Error Resource Pattern
```php
public function onGet(int $id): static
{
    try {
        $user = $this->userRepo->findById($id);
        $this->body = $user;
    } catch (UserNotFoundException $e) {
        $this->code = 404;
        $this->body = ['error' => 'User not found', 'id' => $id];
    }
    return $this;
}
```

## Advanced Features

### JSON Schema Validation
Validate resource schemas automatically:

```php
use BEAR\Resource\JsonSchema\Annotation\JsonSchema;

class User extends ResourceObject
{
    #[JsonSchema('user.json')]
    public function onGet(): static
    {
        // Response automatically validated against JSON schema
    }
}
```

### Options Method Support
Automatic OPTIONS method handling for CORS:

```php
$modules = [
    new ResourceModule('MyApp'),
    new OptionsMethodModule(),
    new OptionsMethodHeaderModule()
];
```

### URI Template Support
Advanced URI templating following RFC 6570:

```php
#[Link(rel: 'search', href: 'app://self/search{?q,page,limit}')]
#[Link(rel: 'user', href: 'app://self/user/{id}{/profile*}')]
```

## Common Log Patterns

When analyzing semantic profiling logs, these patterns help distinguish between development overhead and actual application performance issues:

### Development Profiling Pattern
**Indicators:**
- Generated by: `BEAR\Resource\SemanticLog\DevSemanticInvoker`
- Profile data: `xhprof`, `xdebug`, and/or `php` sections contain detailed profiling information
- Trace content: Shows extensive framework initialization and dependency injection overhead

**Interpretation:**
This is a development environment log with comprehensive profiling enabled. Performance metrics include framework overhead from:
- Dependency injection container operations  
- Development-specific interceptors and observers
- XHProf function call profiling (wall time, memory usage, call counts)
- Xdebug execution trace collection
- PHP backtrace generation and analysis
- Schema validation and semantic logging overhead

**Analysis Focus:**
Focus on application-specific bottlenecks. **Do NOT recommend disabling profiling in development** - this is intentional development tooling that should remain enabled during development for comprehensive analysis. However, these profiling tools (XHProf, Xdebug) should be disabled in production for performance reasons. Look for:
- N+1 query patterns in database calls
- Inefficient algorithms in business logic
- Resource-specific performance issues
- Actual application bottlenecks excluding framework overhead

### Standard Production Pattern  
**Indicators:**
- Generated by: `BEAR\Resource\Invoker`
- Profile data: Empty arrays `[]` or minimal profiling information
- Trace content: Minimal or absent

**Interpretation:**
This represents standard production request processing without development overhead. In production environments, XHProf and Xdebug are typically disabled for performance reasons, resulting in empty profile arrays. Performance metrics reflect actual application performance without development tooling overhead.

**Analysis Focus:**
Direct performance analysis of application code without development tooling interference. When profile data is empty in production logs, this is expected and correct behavior.

---

This comprehensive documentation covers BEAR.Resource's complete feature set for building robust, hypermedia-driven REST APIs with strong typing, dependency injection, and comprehensive observability.